<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>[译]高阶组件在 react hooks 中的应用 | shauvet</title>
    <meta name="description" content="我的 BLOG">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    
    <link rel="preload" href="/assets/css/17.styles.d7a3b500.css" as="style"><link rel="preload" href="/assets/js/app.5ebfa77d.js" as="script"><link rel="preload" href="/assets/js/5.1c7fe777.js" as="script"><link rel="prefetch" href="/assets/js/0.272147ad.js"><link rel="prefetch" href="/assets/js/1.45bd451f.js"><link rel="prefetch" href="/assets/js/2.8e4c1614.js"><link rel="prefetch" href="/assets/js/3.33aff05a.js"><link rel="prefetch" href="/assets/js/4.f764b81a.js"><link rel="prefetch" href="/assets/js/6.c674926d.js"><link rel="prefetch" href="/assets/js/7.ead99731.js"><link rel="prefetch" href="/assets/js/8.a11b5416.js"><link rel="prefetch" href="/assets/js/9.242dfc43.js"><link rel="prefetch" href="/assets/js/10.97faa3c3.js"><link rel="prefetch" href="/assets/js/11.c66eab63.js"><link rel="prefetch" href="/assets/js/12.6303c37e.js"><link rel="prefetch" href="/assets/js/13.3e0a6290.js"><link rel="prefetch" href="/assets/js/14.7ec6bf49.js"><link rel="prefetch" href="/assets/js/15.f06d7b64.js"><link rel="prefetch" href="/assets/js/16.be0aa23d.js">
    <link rel="stylesheet" href="/assets/css/17.styles.d7a3b500.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div><a href="/" class="home-link router-link-active"><!----><span class="site-name">
      shauvet
    </span></a><div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/life/" class="nav-link">博客</a></div><div class="nav-item"><a href="https://cn.bing.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  BING
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav></div></header><div class="sidebar-mask"></div><div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/life/" class="nav-link">博客</a></div><div class="nav-item"><a href="https://cn.bing.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  BING
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><!----></nav><ul class="sidebar-links"><li><a href="/react/" class="sidebar-link">[译]开发类 redux 库来理解状态管理</a></li><li><a href="/react/hocInHooks.html" class="active sidebar-link">[译]高阶组件在 react hooks 中的应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/react/hocInHooks.html#组件本地状态" class="sidebar-link">组件本地状态</a></li><li class="sidebar-sub-header"><a href="/react/hocInHooks.html#组件生命周期" class="sidebar-link">组件生命周期</a></li><li class="sidebar-sub-header"><a href="/react/hocInHooks.html#可测试性" class="sidebar-link">可测试性</a></li><li class="sidebar-sub-header"><a href="/react/hocInHooks.html#分支渲染" class="sidebar-link">分支渲染</a></li><li class="sidebar-sub-header"><a href="/react/hocInHooks.html#属性转换" class="sidebar-link">属性转换</a></li><li class="sidebar-sub-header"><a href="/react/hocInHooks.html#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/react/fetchDataWithReduxAndHooks.html" class="sidebar-link">通过 Redux 和 Hooks 无缝获取数据</a></li><li><a href="/react/reselect.html" class="sidebar-link">通过 Reselect 来理解 Javascript 选择器</a></li><li><a href="/react/buildHighlyCustomizableComponent.html" class="sidebar-link">如何编写高定制化的 React 组件</a></li></ul></div><div class="page"><div class="content"><h1 id="译-高阶组件在-react-hooks-中的应用"><a href="#译-高阶组件在-react-hooks-中的应用" aria-hidden="true" class="header-anchor">#</a> [译]高阶组件在 react hooks 中的应用</h1><ul><li><p>对于那些经常使用 react 的人来说，很难不遇到<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener noreferrer">高阶组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>(或者 HoC's)。对于外行来说，它是一种让 react 组合本身以让代码可以复用到不同的组件的一直模式。即使你没有自己写过，也很有可能在你没有意识到的时候使用过它们。</p></li><li><p>常见的使用模式可以从连接项目工程与状态管理存储(例如： <a href="https://www.sohamkamani.com/blog/2017/03/31/react-redux-connect-explained/" target="_blank" rel="noopener noreferrer">redux<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 里面的 <code>connect</code>)到<a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#branch" target="_blank" rel="noopener noreferrer">条件渲染组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>或者我最喜欢的模式即赋予函数组件本地状态。</p></li><li><p>概念上来说，高阶组件是使用一些叫做增强器的函数包裹一个基础组件来组成的。增强器可以通过多种方式转换或者影响一个基础组件。这类似于 <a href="https://en.wikipedia.org/wiki/Map_%28higher-order_function%29" target="_blank" rel="noopener noreferrer">map 函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可以对一组数据进行转换并生成一组新的数据。如果你仍然有一点困惑，可以看下这个例子：</p></li><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// A simple component</span>
<span class="token keyword">const</span> <span class="token function-variable function">HelloComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> <span class="token operator">...</span>otherProps <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> 
                          <span class="token punctuation">(</span><span class="token operator">&lt;</span>div <span class="token punctuation">{</span><span class="token operator">...</span>otherProps<span class="token punctuation">}</span> <span class="token operator">&gt;</span>
                              Hello <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">!</span>
                           <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// An enhancer that will set a name prop on </span>
<span class="token comment">// a base component to &quot;New Name&quot;</span>
<span class="token keyword">const</span> <span class="token function-variable function">withNameOverride</span> <span class="token operator">=</span> BaseComponent <span class="token operator">=&gt;</span> props <span class="token operator">=&gt;</span>
                             <span class="token punctuation">(</span><span class="token operator">&lt;</span>BaseComponent 
                                 <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span>
                                 name<span class="token operator">=</span><span class="token string">&quot;New Name&quot;</span> 
                              <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// An enhancer that will apply some inline</span>
<span class="token comment">// styling to a base component</span>
<span class="token keyword">const</span> <span class="token function-variable function">withStyling</span> <span class="token operator">=</span> BaseComponent <span class="token operator">=&gt;</span> props <span class="token operator">=&gt;</span>
                            <span class="token punctuation">(</span><span class="token operator">&lt;</span>BaseComponent 
                                <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span>
                                style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span>
                                        font<span class="token operator">-</span>weight<span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">,</span> 
                                        color<span class="token punctuation">:</span> <span class="token string">'green'</span>
                                       <span class="token punctuation">}</span><span class="token punctuation">}</span> 
                             <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Higher Order Components</span>
<span class="token keyword">const</span> EnhancedHello1 <span class="token operator">=</span> <span class="token function">withNameOverride</span><span class="token punctuation">(</span>HelloComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> EnhancedHello2 <span class="token operator">=</span> <span class="token function">withStyling</span><span class="token punctuation">(</span>HelloComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> EnhancedHello3 <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>withNameOverride<span class="token punctuation">,</span> withStyling<span class="token punctuation">)</span>HelloComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>在这个片段中，<code>HelloComponent</code> 是一个我们可以通过 <code>withNameOverride</code> 和/或者 <code>withStyling</code> 增强的组件。</p></li><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>EnhancedHello1 name<span class="token operator">=</span><span class="token string">'World'</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token comment">//becomes</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello New <span class="token class-name">Name</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>EnhancedHello2 name<span class="token operator">=</span><span class="token string">'World'</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token comment">//becomes</span>
<span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> fontWeight<span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">,</span>color<span class="token punctuation">:</span> <span class="token string">'green'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Hello World<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>EnhancedHello3 name<span class="token operator">=</span><span class="token string">'World'</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token comment">//becomes</span>
<span class="token operator">&lt;</span>div style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> fontWeight<span class="token punctuation">:</span> <span class="token number">700</span><span class="token punctuation">,</span>color<span class="token punctuation">:</span> <span class="token string">'green'</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Hello New <span class="token class-name">Name</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div></li><li><p>这是一项简单的例子，展示了高阶组件是如何帮助我们写出高度组合性的代码。许多人想到<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener noreferrer">高阶组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候，很难不想到一个非常可靠的增强器的库，<a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener noreferrer">Recompose<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。每周140多万次下载，完全可以说它是一个很流行的纯粹地由高阶组件开发的库。这足以说明高阶组件的一些最佳应用。</p></li><li><p>对许多 react 开发者来说，高阶组件是生态系统中必不可少的一部分。至少是在2018年10月之前，react 大会召开之前是这样的。在这次大会上 react 团队推出了 hooks。</p></li><li><iframe width="700" height="393" src="https://www.youtube.com/embed/wXLf18DsV-I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen"></iframe></li><li><p>与 Recompose 的作者一起建造，hooks 被认为是各方面都比高阶组件更好的解决方案。甚至 Recompose 的作者更新了 <a href="https://github.com/acdlite/recompose#a-note-from-the-author-acdlite-oct-25-2018" target="_blank" rel="noopener noreferrer">readme<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 建议人们转到 hooks。</p><blockquote><p>Hooks 解决了我三年前尝试使用 Recompose 解决的问题，不止如此。我将停止对此包 [Recompose] 的主动维护。</p></blockquote></li><li><p>这份声明强烈而且分裂了许多已经非常习惯使用 Recompose 的开发者(包括我自己)。我们已经使用高阶组件的可组合性开发了大量的应用，很难相信 hooks 能够神奇的全部替换掉它。这使我更加好奇是否仍然有在新的 react 开发中使用高阶组件的必要性。我列了几个我使用高阶组件的例子，以及他们如何在前 hooks 环境中叠加。</p></li></ul><h2 id="组件本地状态"><a href="#组件本地状态" aria-hidden="true" class="header-anchor">#</a> 组件本地状态</h2><ul><li>我喜欢尽可能的写函数组件。类组件随着尺寸增长会变得越来越难以预测以及难以维护。Recompose 提供了一种增强器通过一种方式来组合本地状态和函数组件，这让我不必为了如何写组件而妥协。而 hooks 从一开始就是被设计用在函数组件内解决这种问题的，hooks 改变了游戏。<a href="https://reactjs.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener noreferrer">useState<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 钩子允许我所需要的所有状态管理逻辑，而且读写还非常简洁优雅。在之前的每一个使用 <a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#withstate" target="_blank" rel="noopener noreferrer">withState<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的地方我全都直接换成了 <code>useState</code>。</li></ul><h2 id="组件生命周期"><a href="#组件生命周期" aria-hidden="true" class="header-anchor">#</a> 组件生命周期</h2><ul><li>又一次，hooks 赢了。<a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener noreferrer">useEffect<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 简化了在组件中增加副作用的必要的理解。跟 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 不同，在一个推迟的事件中，被传递给 <code>useEffect</code> 的函数在布局和绘图之后才会执行。这使得它很适合常见的副作用，如订阅 subscriptions 和事件处理器，因为大多数类型的工作不应该阻止浏览器更新屏幕。此外，<code>useEffect</code> 提供了一种简单的方式来编写简洁的代码，这有助于组件渲染中在下一次作用执行之前清理前一次的作用。Recompose 和 <a href="https://www.npmjs.com/package/@hocs/with-lifecycle" target="_blank" rel="noopener noreferrer">withLifecycle<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 提供了高阶组件的解法，但是没有提供 <a href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_blank" rel="noopener noreferrer">useEffect<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 的简洁用法。我还没有达到这个生命周期高阶组件可以解决地更好的 hook 钩子的极限。</li></ul><h2 id="可测试性"><a href="#可测试性" aria-hidden="true" class="header-anchor">#</a> 可测试性</h2><ul><li>早期让我倾向于高阶组件的一个原因是他们可以模块化。模块化使得它们对单元测试非常友好。然而，hooks 这玩意并非是激情过后的产物。hooks是很多人花很多精力创造出来的。其中之一就是<a href="https://reactjs.org/docs/hooks-faq.html#how-to-test-components-that-use-hooks" target="_blank" rel="noopener noreferrer">可测试性<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。已经有正在积极维护的<a href="https://github.com/mpeyper/react-hooks-testing-library" target="_blank" rel="noopener noreferrer">很奇妙的库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>被用来测试 hooks。在这方面，两种模式在许多方面都是类似，然而，在某些方面可以证明这是必要的。</li></ul><h2 id="分支渲染"><a href="#分支渲染" aria-hidden="true" class="header-anchor">#</a> 分支渲染</h2><ul><li><p>考虑下这种情况：</p></li><li><p>你有一个组件接收 <code>bar</code> 属性并且将它提供给一个函数，这个函数从一些请求返回 <code>{ results, loading, error }</code>。当 <code>loading</code> 被定义的时候，你需要渲染一个 loading 提示组件。当 <code>error</code> 被定义的时候，你需要渲染一个 error 组件。只有当 <code>loading</code> 和 <code>error</code> 都没有定义时，你才可以认为 <code>result</code> 是合法的。</p></li><li><p>hooks 的实现看起来像这样(假设 <code>useRequest</code> 是一个使用 hooks 进行请求的非凡函数)：</p></li><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> bar <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> loading<span class="token punctuation">,</span> error <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useRequest</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>ErrorComponent <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>loading<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>LoadingComponent <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>ResultComponent result<span class="token operator">=</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>这初看起来挺合理的，但是如果我们不得不重复几十次不同的请求时是什么样呢？你可能会拷贝或粘贴这个条件块到每一个条件里面不同的应用，它可能需要在内部测试。</p></li><li><p>一个高阶组件实现可以像这样重组：</p></li><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> result <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>ResultComponent result<span class="token operator">=</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">withRequest</span> <span class="token operator">=</span> BaseComponent <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> bar<span class="token punctuation">,</span> <span class="token operator">...</span>props <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> result<span class="token punctuation">,</span> loading<span class="token punctuation">,</span> error <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useRequest</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>BaseComponent <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> result<span class="token operator">=</span><span class="token punctuation">{</span>result<span class="token punctuation">}</span> loading<span class="token operator">=</span><span class="token punctuation">{</span>loading<span class="token punctuation">}</span> error<span class="token operator">=</span><span class="token punctuation">{</span>error<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> withError <span class="token operator">=</span> <span class="token function">branch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> error <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> error<span class="token punctuation">,</span> ErrorComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> withLoading <span class="token operator">=</span> <span class="token function">branch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> loading <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> loading<span class="token punctuation">,</span> LoadingComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  withRequest<span class="token punctuation">,</span> 
  withLoading<span class="token punctuation">,</span>
  withError
<span class="token punctuation">)</span><span class="token punctuation">(</span>Foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>虽然它肯定有更多行，但是需要注意的是每个常量的模块性。<a href="https://github.com/acdlite/recompose/blob/master/docs/API.md#branch" target="_blank" rel="noopener noreferrer">branch<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 是一个来自 Recompose 的增强器，它接收一个测试函数和两个高阶组件。测试函数从所有者那里传递属性。如果它返回 true，那么 <code>left</code> 组件会被应用，否则，右边的组件会被应用。当我们把所有块组合起来时，表现跟之前一样。当我们考虑与以前相同的假设时，想想如何为数十个类似结构的请求测试，好处就变得明显了。我们需要测试一次 <code>withError</code> 和 <code>withLoading</code>，我们可以复用这个逻辑很多次，当我们仍然想维持相同的测试覆盖率而无需写新的测试用例。</p></li></ul><h2 id="属性转换"><a href="#属性转换" aria-hidden="true" class="header-anchor">#</a> 属性转换</h2><ul><li><p>考虑下这种情况：</p></li><li><p>你有一个组件，接收一个 <code>foo</code> 属性，但是在被使用前要被转换为 <code>bar</code>。在咨询 Hooks API 的参考资料获取指导之后，我真的不知道 hooks 该如何解决这个问题(如果你正好指导如何使用 hooks 解决，请留言让我知道)。然而，这里有一个高阶组件的解决方案：</p></li><li><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">Result</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> bar <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>ResultComponent result<span class="token operator">=</span><span class="token punctuation">{</span>bar<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">withBar</span> <span class="token operator">=</span> BaseComponent <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token punctuation">,</span> <span class="token operator">...</span>props <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>BaseComponent <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> bar<span class="token operator">=</span><span class="token punctuation">{</span><span class="token function">transform</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withBar</span><span class="token punctuation">(</span>Result<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li><li><p>而且即使在这种情况下 <code>withProps</code> 也可以替换 <code>withBar</code> 的很多应用。然而，为清晰起见，我选择更加精确的方案。</p></li></ul><h2 id="总结"><a href="#总结" aria-hidden="true" class="header-anchor">#</a> 总结</h2><ul><li><p>比较高阶组件和 hooks 是一个天真的争论。hooks 的确可以以更加优雅的方式解决一些我们曾经只能通过高阶组件（使用 recompose ）处理的大的挑战。然而，如果你走近看，明显的是高阶组件在 react 中仍然有用武之地。</p></li><li><p>在我的使用高阶组件的分支渲染的例子中，我试图使用同被使用在 hooks 的例子中相同的 <code>useRequest</code> 函数。你有注意到吗？在任何情况下它都是兼容的。这里的目的是为了表明 hooks 可以很好地处理很多像状态和生命周期的这样大的概念，但是使用它的代码也可以从高阶组件的可组合性和模块性中受益。</p></li><li><p>Recompose 的作者关于 hooks 的声明绝对是大胆的，但不完全是事实。如果有的话，应该是这样：</p><blockquote><p>Hooks 解决了许多我三年前试图用 Recompose 来解决的问题。由于这一点，一些工具现在不太有用了，因此我推荐大家看下 hooks。</p></blockquote></li><li><p>那么回到文章的标题，Recompose 在 React Hooks  世界里的作用减少了，但是至少到目前为止，高阶组件仍然有用。</p></li></ul></div><div class="page-edit"><!----><!----></div><div class="page-nav"><p class="inner"><span class="prev">
        ← <a href="/react/" class="prev router-link-active">
          [译]开发类 redux 库来理解状态管理
        </a></span><span class="next"><a href="/react/fetchDataWithReduxAndHooks.html">
          通过 Redux 和 Hooks 无缝获取数据
        </a> →
      </span></p></div></div></div></div>
    <script src="/assets/js/5.1c7fe777.js" defer></script><script src="/assets/js/app.5ebfa77d.js" defer></script>
  </body>
</html>
